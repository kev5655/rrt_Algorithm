import dataClass.Obstacles;
import geometry.Rectangle;
import geometry.Point;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public class MyRRT extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    double fieldWidth = 14000;
    double fieldHeight = 8000;
    double field = 1000;
    double stationWidth = 700;
    double stationHeight = 350;
    int numberOfStation = 12;

    double resizeFaktor = 10;

    boolean enableOriginalGame = true;

    Group allNodes;

    @Override
    public void start(Stage primaryStage) throws Exception {

        fieldHeight = fieldHeight / resizeFaktor;
        fieldWidth = fieldWidth / resizeFaktor;
        field = field / resizeFaktor;
        stationWidth = stationWidth / resizeFaktor;
        stationHeight = stationHeight / resizeFaktor;



        Line line = new Line(0, 0, 200, 300);
        line.setFill(Color.BLACK);

        allNodes = new Group();



        Scene scene = new Scene(allNodes, fieldWidth + 300,  fieldHeight + 300);

        //scene.setOnMouseMoved(e -> {
        //    DataClass.Point point = new DataClass.Point(e.getX(), e.getY());
        //    boolean isOver = DataClass.Obstacle.isPointInObstacle(point);
        //    System.out.println(e.getX() + " " + e.getY() + "  " + isOver);
        //});

        primaryStage.setResizable(false);
        primaryStage.setScene(scene);
        primaryStage.show();

        Platform.runLater(() -> {
            showGrid();
            controlGui();
            //testInObstacel();
        });
    }

    private void testInObstacel() {
        int gird = 1;
        for (int x = 0; x < fieldWidth; x+=gird) {
            for (int y = 0; y < fieldHeight; y+=gird) {
                Point point = new Point((double)x, (double)y);
                boolean isOnObstacle = Obstacles.isPointInObstacle(point);
                if(isOnObstacle){
                    javafx.scene.shape.Rectangle r = new javafx.scene.shape.Rectangle(x, y, gird, gird);
                    r.setFill(Color.rgb(0,0,0,0.2));
                    allNodes.getChildren().add(r);
                }
            }
        }

    }

    private void showGrid() {
        List<Line> lines = new LinkedList<>();
        for (double x = 0; x <= fieldWidth; x = x + field) {
            lines.add(new Line(x, 0, x, fieldHeight));
        }
        for (double y = 0; y <= fieldHeight; y = y + field) {
            lines.add(new Line(0, y, fieldWidth, y));
        }

        allNodes.getChildren().addAll(lines);
    }

    private void controlGui(){
        List<Integer> location = new LinkedList<>();
        List<Integer> blockingLocation = new LinkedList<>();
        location.add(Integer.MAX_VALUE);

        for (int i = 0; i < numberOfStation; i++) {

            int angle = generateAngle();
            Point pointOfMiddleField = generatePointOnRandomField(location, angle);


            List<Point> points = getAllPointsOfRect(pointOfMiddleField.getX(),
                    pointOfMiddleField.getY(), angle);

            angle +=90;
            if(angle <= 360) angle = 0;

            new Rectangle(points.get(0), points.get(1), points.get(2), points.get(3), angle);
        }

        allNodes.getChildren().add(new ObstacleDrawer().getObstacles());
    }

    private int generateAngle(){
        Random rand = new Random();
        int angle = 0;
        switch (rand.nextInt(8)){
            case 0 -> angle = 0;
            case 1 -> angle = 45;
            case 2 -> angle = 90;
            case 3 -> angle = 135;
            case 4 -> angle = 180;
            case 5 -> angle = 225;
            case 6 -> angle = 270;
            case 7 -> angle = 315;
        }
        return angle;
    }

    private Point generatePointOnRandomField(List<Integer> location, int angle){
        Random rand = new Random();
        Integer R = null;
        int xR, yR;
        do{
            xR = rand.nextInt((int)(fieldWidth / 100));
            yR = rand.nextInt((int)(fieldHeight / 100));
            if (isInEntryZone(xR, yR)) R = Integer.MAX_VALUE;
            else {
                R = xR + yR;
                //blockZoneForThisStation(xR, yR, angle, location);
            }
        }while(location.contains(R));

        location.add(R);

        double x = (xR * field) + (field / 2);
        double y = (yR * field) + (field / 2);

        return new Point(x, y);
    }

    private boolean isInEntryZone(int xR, int yR){
        if(enableOriginalGame){
            if(yR == 7 &&
                    (xR == 0 || xR == 1 || xR == 1 || xR ==11 || xR == 12 || xR == 13)){
                return true;
            }
        }
        return false;
    }

    private void blockZoneForThisStation(int xR, int yR, int angle, List<Integer> location) {
        //switch (angle){
            //case 0 -> location.add(xR + 1 + yR); location.add(xR - 1 + yR);
            //case 45 -> ;
            //case 90 -> ;
            //case 135 -> ;
            //case 180 -> ;
            //case 225 -> ;
            //case 270 -> ;
            //case 315 -> ;
        //}
    }





    private List<Point> getAllPointsOfRect(double x, double y, double angle){
        double x1diff = (stationWidth / 2) * Math.cos(Math.toRadians(angle)) - (stationHeight / 2) * Math.sin(Math.toRadians(angle));
        double y1diff = (stationWidth / 2) * Math.sin(Math.toRadians(angle)) + (stationHeight / 2) * Math.cos(Math.toRadians(angle));
        double x1 = x - x1diff;
        double y1= y - y1diff;

        double x2diff = (stationWidth / 2)  * Math.cos(Math.toRadians(angle)) - (stationHeight / 2) * -1 * Math.sin(Math.toRadians(angle));
        double y2diff = (stationWidth / 2)  * Math.sin(Math.toRadians(angle)) + (stationHeight / 2) * -1 * Math.cos(Math.toRadians(angle));
        double x2 = x - x2diff;
        double y2= y - y2diff;


        double x3diff = (stationWidth / 2) * -1 * Math.cos(Math.toRadians(angle)) - (stationHeight / 2)  * Math.sin(Math.toRadians(angle));
        double y3diff = (stationWidth / 2) * -1 * Math.sin(Math.toRadians(angle)) + (stationHeight / 2)  * Math.cos(Math.toRadians(angle));
        double x3 = x - x3diff;
        double y3= y - y3diff;

        double x4diff = (stationWidth / 2) * -1 * Math.cos(Math.toRadians(angle)) - (stationHeight / 2) * -1 * Math.sin(Math.toRadians(angle));
        double y4diff = (stationWidth / 2) * -1 * Math.sin(Math.toRadians(angle)) + (stationHeight / 2) * -1 * Math.cos(Math.toRadians(angle));
        double x4 = x - x4diff;
        double y4= y - y4diff;

        Point p1 = new Point(x1, y1);
        Point p2 = new Point(x2, y2);
        Point p3 = new Point(x3, y3);
        Point p4 = new Point(x4, y4);

        return List.of(p1, p2, p3, p4);
    }
}
